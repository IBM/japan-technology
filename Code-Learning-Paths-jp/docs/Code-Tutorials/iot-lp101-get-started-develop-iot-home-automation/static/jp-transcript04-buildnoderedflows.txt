ホーム・オートメーション・システムを制御するフローを作成する作業を開始します。

最初に取り掛かるのは、PIR センサーとブザーに対応するノードの作成です。ここに Raspberry Pi GPIO ノードがリストアップされています。センサーのノードは、左側に Raspberry Pi アイコンが示されているこのノードになります。このノードは入力ノードです。このノードをフローの中にドロップし、ダブルクリックして構成できる状態にします。このノードは、センサーと同じピンにセットアップする必要があります。ピン 7 です。これらの値については現時点で考える必要はありませんが、名前は指定します。「PIR センサー」と入力し、フロー内でこのノードを識別できるようにします。センサーがトリガーされるたびに、このノードからメッセージが送信されます。このメッセージのペイロードには、未加工のセンサー測定値が格納されています。

次にセットアップするのは、ブザーに対応する GPIO ノードです。今回は、出力ノードになります。このノードを使用して、センサーがトリガーされたことを、ブザーのビープ音によって確認できるようにします。この GPIO ノードをフロー内にドラッグし、ダブルクリックして編集します。このノードをピン 11 にセットアップして、ブザーに対応させます。出力ノードなので、設定項目は少々異なっていますが、ここではデジタル出力です。センサーと同じように名前を付けて、このノードを「ブザー」という名前にします。

この入力ノードを出力ノードに直接接続して、センサーがトリガーされるたびにブザーが鳴るようにすることもできますが、そうすると、センサーがトリガーされている間、ずっとビープ音が鳴り続けることになります。そこで、トリガー・ノードを見つけて、この 2 つのノードの間にドロップします。センサーの出力をトリガーの入力に接続し、トリガーの出力にブザーの入力を接続します。トリガーを構成して、ブザーが短い間だけトリガーされるようにすることができます。200 ミリ秒に設定すれば、短いビープ音になります。トリガーをリセットすることもできます。センサーの値がゼロになるたびにトリガーをリセットするようにすれば、センサーがアクティブになったときにだけブザーがトリガーされることになります。つまり、センサーの値が 1 のときだけトリガーされます。

ここまでの作業が終わったら、このフローをデプロイしてテストすることができます。モーション・センサーをアクティブにすると、ブザーのビープ音が聞こえるようでなければなりません。個々のノードのステータスは、リアルタイムで更新されます。したがって、センサーがトリガーされるたびに、実際のセンサーの値がノードの下に示されます。また、ブザーが鳴るたびに、ブザーの値もノードの下に表示されます。ブザーが機能することがわかりました。センサーもデータを読み取っています。ですが、私が確認したいのは、このノードから送られてくる実際のメッセージです。それには、デバッグ・ノードをグラブして、フローの中にドロップします。センサーから送られてくるメッセージをデバッグ・ノードに取り込みます。このノードは、メッセージ全体を表示するように構成することができます。このフ
ローをデプロイすると、センサーがトリガーされるたびに、センサー・ノードから送られてくるメッセージ全体をデバッグ・パネルで確認できるようになります。ペイロードは、センサーがアクティブになったかどうかによって、1 または 0 として示されます。作業している間は、このブザーの接続を外して、モーション・センサーをテストするたびにブザーがトリガーされることがないようにします。デバッグ・ノードも削除できます。すでにメッセージの内容を確認したからです。

次は、ホーム・キット・ノードを追加します。このホーム・キット・ノードに何よりもまず必要なのは、このノードにホーム・キット・アクセサリーを構成することです。さらに、ピン・コードを構成する必要もあります。iOS デバイスからアクセサリーに接続する際に、構成済みのピン・コードを入力して接続するという仕組みにするためです。これらの値はデフォルトのままで構いませんが、アクセサリーのタイプはセンサーとして構成し、ノードに名前を付けます。「モーション・センサー」という名前にします。アクセサリーをセットアップしたので、インスタンスを作成します。このインスタンスはモーション・センサーになります。ノードに名前を付けます。このセンサーは玄関のドアに接続するので、「ドア・センサー」という名前にします。

ホーム・キット・ノードの構成が完了したので、これをセンサーに接続します。PIR センサーからの値がホーム・キット・ノードにフィードされると、このノードがトリガーされて iOS デバイス上に表示されることになります。ただし、センサーからの値をそのまま使って、1 または 0 と表示することはしたくありません。値を変換して、ホーム・キット・ノードで理解できる形式にします。このノードがペイロード内に期待するキーを知るために、関数を追加します。ここにダミー値をいくつか送信します。仮に、メッセージ・ペイロードが foobar になるように設定します。この関数をホーム・キット・ノードに接続します。センサーを関数に接続して、センサーがアクティブになるとトリガーされるようにします。これで、センサーがアクティブになると、ホーム・キット・ノードからのメッセージが表示されて、そのメッセージに、ホーム・キット・ノードがペイロード内に期待する特性、つまりキーが示されるはずです。目的のキーは、「motion detected」となっています。このキーを、センサーの未加工の測定値に基づいて設定する必要があります。変換関数を更新して、「motion detected」と設定します。このキーを、PIR センサーから送られてくるメッセージ・ペイロードの値に設定します。つまり、センサーからの未加工の測定値に設定します。

このバージョンのフローをデプロイすると、センサーがトリガーされるたびに、モーション・センサーの値が 1 または 0 に設定されてドア・センサーの下に示されるようになります。この値はブール値にするべきでしょう。そこで、変換関数を微調整して、未加工の値ではなくなるようにします。それには、最も簡単な方法として、否定演算子を使います。未処理の値を 2 回否定すると、値がブール値に変換されることになります。成功です。センサーがトリガーされたかどうかによって、motion detected は true または false になります。

このフローを iPhone 上のホーム・アプリに追加しましょう。ホーム・アプリを開くと、モーション・センサーがポップアップ表示されています。認定されていないため機能しない可能性があるというメッセージが表示されますが、Raspberry Pi を使用してセットアップすると常にこのメッセージが表示されるので、問題はありません。コードを手入力します。モーション・センサーとペアリングするまで待ちます。完了しました。これがデフォルトのドア・センサーです。「Done (完了)」をクリックします。センサーをトリガーします (ビープ音)。見てください。トリガーされたことが示されています。これで、Apple TV または iPad を使って、このフローをホーム・オートメーション・フローの一部としてセットアップすることができます。


