import{u as E,q as w,i as S}from"./RnsC1jSz.js";import{q as v,e as b,Y as M,l as g,B as I,v as P,i as x,p as U,X as C}from"./Bsy4XOlU.js";import{r as j}from"./B0Xm9tiF.js";function q(){const a=M(),e=v(),r=b(()=>["#text","#comment"].includes(e.value?.$el.nodeName)?e.value?.$el.nextElementSibling:E(e)),o=Object.assign({},a.exposed),s={};for(const t in a.props)Object.defineProperty(s,t,{enumerable:!0,configurable:!0,get:()=>a.props[t]});if(Object.keys(o).length>0)for(const t in o)Object.defineProperty(s,t,{enumerable:!0,configurable:!0,get:()=>o[t]});Object.defineProperty(s,"$el",{enumerable:!0,configurable:!0,get:()=>a.vnode.el}),a.exposed=s;function u(t){e.value=t,t&&(Object.defineProperty(s,"$el",{enumerable:!0,configurable:!0,get:()=>t instanceof Element?t:t.$el}),a.exposed=s)}return{forwardRef:u,currentRef:e,currentElement:r}}function F(a,e){const r=v(a);function o(u){return e[r.value][u]??r.value}return{state:r,dispatch:u=>{r.value=o(u)}}}function _(a,e){const r=v({}),o=v("none"),s=v(a),u=a.value?"mounted":"unmounted";let t;const m=e.value?.ownerDocument.defaultView??w,{state:d,dispatch:l}=F(u,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),i=n=>{if(S){const c=new CustomEvent(n,{bubbles:!1,cancelable:!1});e.value?.dispatchEvent(c)}};g(a,async(n,c)=>{const h=c!==n;if(await P(),h){const y=o.value,f=N(e.value);n?(l("MOUNT"),i("enter"),f==="none"&&i("after-enter")):f==="none"||f==="undefined"||r.value?.display==="none"?(l("UNMOUNT"),i("leave"),i("after-leave")):c&&y!==f?(l("ANIMATION_OUT"),i("leave")):(l("UNMOUNT"),i("after-leave"))}},{immediate:!0});const p=n=>{const c=N(e.value),h=c.includes(CSS.escape(n.animationName)),y=d.value==="mounted"?"enter":"leave";if(n.target===e.value&&h&&(i(`after-${y}`),l("ANIMATION_END"),!s.value)){const f=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",t=m?.setTimeout(()=>{e.value?.style.animationFillMode==="forwards"&&(e.value.style.animationFillMode=f)})}n.target===e.value&&c==="none"&&l("ANIMATION_END")},A=n=>{n.target===e.value&&(o.value=N(e.value))},O=g(e,(n,c)=>{n?(r.value=getComputedStyle(n),n.addEventListener("animationstart",A),n.addEventListener("animationcancel",p),n.addEventListener("animationend",p)):(l("ANIMATION_END"),t!==void 0&&m?.clearTimeout(t),c?.removeEventListener("animationstart",A),c?.removeEventListener("animationcancel",p),c?.removeEventListener("animationend",p))},{immediate:!0}),T=g(d,()=>{const n=N(e.value);o.value=d.value==="mounted"?n:"none"});return I(()=>{O(),T()}),{isPresent:b(()=>["mounted","unmountSuspended"].includes(d.value))}}function N(a){return a&&getComputedStyle(a).animationName||"none"}var B=x({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(a,{slots:e,expose:r}){const{present:o,forceMount:s}=U(a),u=v(),{isPresent:t}=_(o,u);r({present:t});let m=e.default({present:t.value});m=j(m||[]);const d=M();if(m&&m?.length>1){const l=d?.parent?.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${l}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(i=>`  - ${i}`).join(`
`)].join(`
`))}return()=>s.value||o.value||t.value?C(e.default({present:t.value})[0],{ref:l=>{const i=E(l);return typeof i?.hasAttribute>"u"||(i?.hasAttribute("data-reka-popper-content-wrapper")?u.value=i.firstElementChild:u.value=i),i}}):null}});export{B as P,q as u};
